---------
Решения: |
---------

1. Първоначално проверявам подадените аргументи - дали техният брой е в интервала [1;4), защото от условието се изисква да се 
въведе име на съществуващ файл; думите country, zones или distance; една позивна, ако вторият аргумент е country или zones, 
или две позивни, ако вторият аргумент е distance.

2. След направената валидация на аргументите, проверяваме дали въведеният файл съществува в текущата директория. Ако не 
съществува, извеждаме съобщение за грешка и прекратяваме работата на скрипта.

3. След всички направени проверки създаваме: 

FILE=$(mktemp)
COMMAND="${2}"
SIGN="${3}"

Създаваме FILE като временен файл, защото в Бонус 1 имаме изискване, че ако се въведе environment променлива CTY_FORMAT със 
стойност DAT, скриптът да приеме, че се използва този алтернативен формат на дадения файл cty.dat. Идеята ми е следната:
В скрипта правим проверка дали е въведена такава променлива с командата: 

printenv | egrep -q "^CTY_FORMAT=DAT$"

Ако е въведена такава променлива, то тогава отбелязваме с променливата BEEN ( BEEN=$((BEEN+1)) ), че сме влезли в този 
случай, а след това:Прочитаме въведения файл. В него въведената информация съдържа много интервали между отделните колони, 
заради това "свиваме" информацията вътре спрямо празното място. Заместваме запетаите с интервал, защото запетаите се намират 
между правилата, а в оригиналния файл cty.csv правилата са с интервал помежду си. След тази стъпка заместваме двете точки и 
интервала (: ) със запетаи, защото в оригиналния файл cty.csv отделните колони са разделени със запетаи, а тук са с две 
точки и интервал (: ). Искам да подчертая, че изтриваме две точки и интервал (: ), което означава, че последните две точки (:) 
от всеки ред няма да бъдат изтрити, защото след последните две точки липсва такъв интервал (това ще го направим на по-късен 
етап). След това изтриваме празните места, с които започват някои от редовете, защото следващата ни цел е да слеем абсолютно 
всички редове в един цял ред - тоест искаме да прилепим всички редове към първия, за да може после да направим правилното 
разделение на редовете, а ако оставим празните места в началото на всеки ред, то тогава между правилата ще има повече празни 
места. Нататък работата ни е лесна - сега вече заместваме двоеточеието (:) с интервал, защото всички двоеточия (:) се намираха 
между правила, а между правилата трябва да има само интервал (съобразяваме се с формата от cty.csv файла). Всички точки със 
запетаи (;) ги заместваме с точка и запетая, последвано от нов ред (;\n), защото след всяка точка и запетая (;) отиваме на нов 
ред, където има информация за друга държава. Така вече сме разделили колоните, но общо колоните са 8, а на нас ни трябват 10. 
В този случай добавяме 2 нови колони с обща информация, съдържаща числата 1 и 2, защото те няма да ни трябват, а просто трябва 
да го докараме до 10 колони. Крайната стъпка е да подредим колоните по такъв начин, по който са подредени във файла cty.csv, 
за да може да ни работи коректно скрипта. Всички тези промени ги записваме във временно направения файл FILE. Кодът на това 
условие изглежда така:

printenv | egrep -q "^CTY_FORMAT=DAT$"

if [ $? -eq 0 ]; then
          BEEN=$((BEEN+1))
          cat "${1}" \
          | tr -s ' ' \
          | sed 's/,/ /g' \
          | sed 's/: /,/g' \
          | sed 's/^ //g' \
          | tr -d '\r\n' \
          | sed 's/:/ /g' \
          | sed 's/;/;\n/g' \
          | sed 's/^/2,&/g' \
          | sed 's/^/1,&/g' \
          | awk -F ',' '{ print $1","$3","$2","$6","$4","$5","$7","$8","$9","$10 }' >> "${FILE}"
fi

Не е написано никъде в условието, че подаденият файл при envorinment променлива CTY_FROMAT=DAT трябва да има разширение .dat, 
заради това не правя такава проверка. Но ако трябва да се направи проверка, тя може да се вмъкне преди BEEN=$((BEEN+1)):

echo "${1}" | egrep -q ".+\.dat$"
if [$? -eq 0 ]; then
...

В този случай, когато имаме environment променлива CTY_FORMAT=DAT, ако не е въведен .dat файл, то тогава няма да се влезе в 
случай, в който да се "пренареди" информацията във въведения файл и самият скрипт ще приеме директно формата на въведения 

файл 
и ще работи върху него, без да го подрежда по написания начин. Но да приемем, че подадените файлове ще са в един от двата 
формата (ако имаме environment променлива CTY_FORMAT=DAT и е подаден файлът cty.csv, този файл cty.csv ще "пренареди" 
информацията си и скриптът няма да работи коректно, а ще работи коректно само върху файлове с формата на cty.dat. Ако я няма 
тази environment променлива, то тогава ще е обратното - скриптът ще работи коректно за файлове с формата на cty.csv, а ще 
работи некоректно за всички останали формати).

4. Ако не сме влезли в горния случай, тоест BEEN e 0, то тогава прочитаме съдържанието на въведения файл като аргумент 1 и 
го записваме във временния файл FILE.

5. Вече сме готови с информацията във FILE. Сега идва момент, в който трябва да проверим дали въведеният трети аргумент 
(първата позивна) е изпълнила изискванията от условието. Прочитаме името й и проверяваме дали е изпълнено условието името 
да се състои от символите A-Z, 0-9 и от /. Правим следната проверка:

echo "${SIGN}" | egrep -q "^[A-Z0-9]+(/*[A-Z0-9]+)*$"

Като получим позивна, първо да проверим дали тя удовлетворява изискването да се състои само от главни латински букви [A-Z], 
цифри [0-9] и наклонени черти (/). Никъде не е написано в условието дали може да има позивни, които да започват или 
завършват с / (наклонена черта). Също така няма ограничение, свързано с това, дали може едно правило да съдържа в себе си 
няколко последователни наклонени черти (например A//B///C). Доста пъти прегледах cty.csv и не видях никъде да има правило, 
което да изглежда по някой от тези начини. На едно от упражненията попитах за тези ограничения и доколкото разбрах, 

трябваше 
да направя така, че да не може да започва или да завършва правилото с наклонена черта.

Искаме задължително подадената позивна да започва най-малко с една главна латинска буква или цифра,(1) след това може да 
имаме безброй много наклонени черти, като след последната наклонена черта искаме задължително да има най-малко една главна 
латинска буква или цифра, за да избегнем завършването с наклонена черта, и цялата тази комбинация от (1) нататък може да 
се повтаря безброй пъти, като не искаме след целия този израз да има други символи. Ако не искаме да има последователност 
от наклонени черти, след наклонената черта вместо * трябва да има ? или {,1}.

Ако тези изисквания не са изпълнени, извеждаме съобщение за грешка и прекратяваме работата на скрипта.

Ако изискванията са изпълнени, то тогава трябва да проверим и втората позивна, ако има такава (ако въведената команда е 
distance и броят на аргументите е 4):
echo "${SECOND_SIGN}" | egrep -q "^[A-Z0-9]+(/*[A-Z0-9]+)*$"

Проверяваме по същия начин, както и за първата позивна.

Ако втората позивна не е изпълнила изискванията, се извежда грешка като съобщение и се прекратява скриптът.

6. За да избегнем повторение на код, е необходимо да създадем функции, които да използваме за решаването на отделните 
подточки. Функциите са:

function findSign -> главна функция, която се използва във всички подточки за идентифициране на въведена позивна

function convertToRadians -> помощна функция за в) (за намиране на разстояние между държави)

function getDistance -> главна функция, която използваме за в)

function checkHomeCountry -> помощна функция, която използваме за Бонус 2 (проверяваме при въведени аргументи country 
позивна дали въведената позивна съдържа / (наклонена черта), за да вземем тази част след / (наклонена черта), защото 
по условие при Бонус 2 втората част от позивната, тоест след наклонената черта, е родната държава, която трябва да 
изведем в скоби)

function findCountry -> главна функция за решението на а) и Бонус 2

function findZones -> главна функция за решението на б)

function findDistance -> главна функция за решението на в)

7. function findSign: Създаваме си променлива INPUT_SIGN, в която записваме подадената позивна (INPUT_SIGN="${1}", 
защото в случая "${1}" е първи аргумент във функцията findSign, а не в целия скрипт - тоест към тази функция подаваме 
един параметър, на базата на който ще търсим в подадения ни файл). 

I. Трябва да проверим дали в целия въведен файл се среща нашата позивна със знак = пред нея. По условие пише, че ако 
позивната
ни е от тип 1, тоест има знак = пред себе си, то тогава се определя някоя конкретна позивна (уникална е). Заради това 
правим следната проверка:

cat "${FILE}" \
| cut -d ',' -f10 \
| sed 's/^/",",&/g' \
| egrep -q "=${INPUT_SIGN}(\([0-9]+\))?(\[[0-9]+\])?( |;)"

Прочитаме съдържанието, записано във FILE и изрязваме колона 10, защото там са всички правила, а ние търсим именно 
в тях. След като изрежем колона 10 спрямо символа запетая, то тогава ни се извежда колона 10 без запетаята, но на 
нас тя ни е необходима, за да определим кога точно може да започва едно правило (то може да има пред себе си или
запетая, или празно място). Заради това добавяме запетая към изведената информация и вече имаме всичко необходимо, 
за да направим проверката. Искаме пред въведената позивна задължително да има знак = , защото в случая той е от 
значение за определяне на уникалността на позивната. След съответната позивна може да има най-много по едно срещане 
за WAZ и ITU зони (например YH8(11), YH8[11], YH8(11)[10]). Накрая искаме намерената от нас позивна да завършва или 
с интервал, или с ; (точка и запетая). По този начин ние хващаме по подходящ начин търсената от нас позивна и 
проверяваме дали е уникална.

Ако сме намерили такова правило, което да определя позивната като уникална, то тогава няма какво повече да търсим. 
Заради това търсим в целия файл въведената позивна и я изкарваме по начин, по който е намерена (включително със 
символите, които се намират в израза - например може намерената позивна да е така: (интервал)=AXC9[1]; Тогава ние 
искаме функцията да изведе именно това, което е намерило, тоест ние искаме да ни изведе (интервал)=AXC9[1]; , а не 
само AXC9). След като изведем необходимата информация от тази функция, я прекратяваме, защото вече сме намерили това, 
което ни е било необходимо.

II. Ако не сме намерили правило, което да определя позивната като уникална, то тогава идва моментът, в който да 
търсим позивната без знак = пред нея. Как трябва да извършим проверката спрямо условието?
Пример: Търсим позивна CLAS1. Нас ни интересуват позивни, които са поднизове от вида:
C
CL
CLA
CLAS
CLAS1

Ако намерим повече от едно правило, което да удовлетворява условието, то тогава трябва да търсим
най-дългата намерена поредица.
Пример: Търсим позивна CLAS1, обаче тя не съществува. Въпреки това ние търсим нейните поднизове. Може да намерим 
следното:
CL
CLA

В този случай ние ги подреждаме по брой символи и взимаме най-дългия подниз. Ако имаме два или повече низа, които 
са с максимална еднаква дължина, то тогава взимаме някой произволен или първия срещнат. Намираме в подадения файл 
съответната позивна и я извеждаме така, както е намерена: може да е намерена позивна YH[1]; -> тогава ние искаме да 
изведе YH[1];, а не само YH
Като код това изглежда по следния начин:

	SAVE=$(mktemp)

        WORD=""

        while read letter
        do
                WORD=$(echo "${WORD}${letter}")
                cat "${FILE}" \
                | cut -d ',' -f10 \
                | sed 's/^/",",&/g' \
                | egrep -o "( |,)${WORD}(\([0-9]+\))?(\[[0-9]+\])?( |;)" \
                | sed 's/,//g' \
                | sed 's/ //g' \
                | sed -E "s/\(.*//g" \
                | sed -E "s/\[.*//g" \
                | sed 's/;//g' >> "${SAVE}"

        done< <(echo "${INPUT_SIGN}" | grep -o ".")

        LINES=$(cat "${SAVE}" | wc -l)

	if [ "${LINES}" -eq 0 ]; then
                rm "${SAVE}"
                return
        fi

        FOUND_SIGN=$(cat "${SAVE}" \
                     | awk '{ print length, $0 }' \
                     | sort -r \
                     | head -n 1 \
                     | cut -d ' ' -f2)

        FINAL_SIGN=$(cat "${FILE}" \
                     | egrep -o "( |,)${FOUND_SIGN}(\([0-9]+\))?(\[[0-9]+\])?( |;)")

        echo "${FINAL_SIGN}"

        rm "${SAVE}"


Създаваме си временен файл SAVE, в който ще запишем всички намерени позивни, за да може после да го сортираме спрямо 
дължината на низовете и да вземем този, който ни трябва за решението на задачата.

Създаваме си променлива WORD, която първоначално ни е празна. От нея постепенно ще изграждаме необходимите ни думи.

В while цикъла прочитаме въведаната като аргумент позивна, като всяка буква я поставяме на нов ред, за да ни е 
по-лесно да съставяме думите. В началото на цикъла съставяме думата WORD.
Пример: Нека вземем правилото от по-горе - CLAS1.
При първото прочитане WORD ще е C
При второто прочитане WORD ще е CL
При третото прочитане WORD ще е CLA
При четвъртото прочитане WORD ще е CLAS
При петото прочитане WORD ще е CLAS1

Всеки път, след като съставим думата WORD, ние я търсим в колона 10 от подадения като аргумент файл, като отново 
добавяме запетая пред намерените резултати, защото ни трябва запетаята заради отделните случаи, искаме тя да започва 
със , или празно място, после може да бъде последвана от WAZ и ITU зони, ако евентуално има такива обозначени след 
самата позивна, и накрая искаме да завърши с празно място или с ; -> по този начин ние хващаме всички случаи за 
различните комбинации от низове. Всеки срещнат низ, който удовлетворява нашето търсене, го извеждаме на нов ред. 
На този нов ред той може да има останали празни места отпред и отзад, може да има , или да има WAZ и ITU зони. 
Заради това използваме няколко пъти командата sed, за да премахнем срещанията и да останат само и единствено 
правилата, без отделна изведена информация, за да може после да пресметнем правилно дължината на поднизовете и да 
вземем този, който е с най-голяма такава.

Записваме всичко от while във временния файл SAVE и след като свърши while цикъла, проверяваме дали временният файл 
SAVE е празен и ако е празен (тоест, ако не сме срещнали въобще такова правило или негов подниз), изтриваме временния 
файл SAVE и прекратяваме функцията. В противен случай прочитаме файла SAVE, извеждаме дължината на всеки един низ 
(всеки един низ е на отделен ред), след това сортираме, като низът с най-голяма дължина е най-отгоре, взимаме него и 
изрязваме колона 2, за да вземем само името на позивната без нейната дължина, защото не ни е необходима. Намерената 
позивна я записваме в променливата FOUND_SIGN.

Прочитаме подадения като аргумент файл и намираме запомнената позивна FOUND_SIGN, като отново слагаме вариант да 
започва със , (ако се намира непосредствено в началото на колона 10) или да започва с празно място (ако се намира 
по средата), след това слагаме вариант да има най-много по една WAZ зона и/или ITU зона и след това да завършва с 
празно място (ако се намира по средата) или с ; (ако се намира в края). Намерения резултат записваме в променливата 
FINAL_SIGN. След като намерим 
позивната, която ни е необходима, отново я извеждаме така, както е намерена. Изтриваме временния файл SAVE и вече 
можем да кажем, че нашата функция е приключила успешно.

8. function checkHomeCountry: Създаваме си променлива INPUT_SIGN, която взима първия подаден параметър към функцията 
checkHomeCountry (тоест позивна) и проверяваме дали подадената позивна съдържа в името си / (наклонена черта), защото 
за намирането на родна държава това ни е ключово - трябва да има / в името на позивната. Ако в името на позивната се 
съдържа знакът / (наклонена черта), тогава взимаме целия израз след първата срещната наклонена черта и записваме 
резултата в променливата TAKEN. След това използваме функцията findSign за променливата TAKEN (проверяваме в целия 
файл дали има правило, което да съдържа изрязаната част след първата наклонена черта от главната позивна). Записваме 
резултата в променливата FOUND_SIGN. След това проверяваме дали FOUND_SIGN съдържа намерена позивна - тоест дали има 
намерено правило, което ще ни отведе към родната държава. Ако не е намерено, прекратяваме функцията. В противен случай 
прочитаме целия файл FILE, търсим точно подаден израз (заради това използваме fgrep - защото функцията findSign може да 
ни върне позивна от вида (интервал)YH8[10]; и ние искаме да търсим точно тази позивна в целия файл), след като намерим 
тази конкретна позивна, изрязваме втората колона, защото там се съдържат държавите, и приключваме работата на функцията. 
Като код това изглежда така:

function checkHomeCountry
{
	INPUT_SIGN="${1}"

        echo "${INPUT_SIGN}" | grep -q "/"

        if [ $? -eq 0 ]; then
                TAKEN=$(echo "${INPUT_SIGN}" \
                        | cut -d '/' -f2)

                FOUND_SIGN=$(findSign "${TAKEN}")

                if [ -z "${FOUND_SIGN}" ]; then
                        return
                fi

                HOME_COUNTRY=$(cat "${FILE}" \
                               | fgrep "${FOUND_SIGN}" \
                               | cut -d ',' -f2)

                echo "${HOME_COUNTRY}"
        fi
}
   
9. function findCountry: В тази функция първо си създаваме променливата FOUND_SIGN:
FOUND_SIGN=$(findSign "${SIGN}")

Искаме на функцията findSign да подадем позивната SIGN, за да открие във файла FILE дали се среща тази позивна и 
намереният резултат да се запишe в създадената променлива FOUND_SIGN. Ако променливата FOUND_SIGN е празна (не е 
открита позивна), тогава ние изтриваме временния файл FILE и прекратяваме функцията.

След това си създаваме променливата HOME_COUNTRY, в която искаме да запазим намерена родна държава, ако има такава:
HOME_COUNTRY=$(checkHomeCountry "${SIGN}") -> чрез функцията checkHomeCountry ние проверяваме дали позивната SIGN съдържа 
наклонена черта в името си и ако съдържа, да се провери дали частта след първата срещната наклонена черта е позивна от 
някоя държава. Намереният резултат се записва в променливата HOME_COUNTRY.

Търсим във файла FILE точно конкретния израз от FOUND_COUNTRY (заради това използваме fgrep), след което изрязваме втората 
колона, защото там се намира името на търсената държава. Полученият резултат се записва в променливата COUNTRY.

След това проверяваме дали е намерена родна държава - ако не е намерена, то тогава изкарваме само намерената държава 
COUNTRY, а ако е намерена родна държава, тогава извеждаме информацията по следния начин - <намерена държава> 
(<родна държава>) - това е заради условието от Бонус 2. Като код изглежда по следния начин:

function findCountry
{
        FOUND_SIGN=$(findSign "${SIGN}")

        if [ -z "${FOUND_SIGN}" ]; then
                rm "${FILE}"
                exit 0
        fi

        HOME_COUNTRY=$(checkHomeCountry "${SIGN}")
        
        COUNTRY=$(cat "${FILE}" \
                  | fgrep "${FOUND_SIGN}" \
                  | cut -d ',' -f2)

        if [ -z "${HOME_COUNTRY}" ]; then
                echo "${COUNTRY}"
        else
                echo "${COUNTRY} (${HOME_COUNTRY})"
        fi
}

10. function findZones: В тази функция първо си създаваме променливата FOUND_SIGN:
FOUND_SIGN=$(findSign "${SIGN}")

Искаме на функцията findSign да подадем позивната SIGN, за да открие във файла FILE дали се среща тази позивна и намереният 
резултат да се запишe в създадената променлива FOUND_SIGN. Ако променливата FOUND_SIGN е празна (не е открита позивна), 
тогава ние изтриваме временния файл FILE и прекратяваме функцията.

След това ние искаме да проверим дали намерената позивна съдържа собствени WAZ и ITU зони, защото по условие в б), ако една 
позивна изглежда по този начин: YH8[54], то тогава нейната ITU зона е 54, а не тази на държавата. Същото се отнася и за WAZ 
зоната. Ако съответно липсват собствени ITU и WAZ зони за някоя позивна, то тогава взимаме тези от съответната държава - 
така е по условие. 
Заради това прочитаме намерената позивна и търсим в нея дали се среща този символ: [
- Ако се среща, то тогава тази позивна има собствена ITU зона. Следователно прочитаме намерената позивна, изрязваме втората 
колона след символа [, след това изрязваме първата колона спрямо символа ] и съответния резултат го записваме в променлива, 
което се казва ITU. Намерили сме ITU зона за подадената позивна.
- Ако не се среща, то тогава прочитаме целия файл, подаваме точно конкретно намерената позивна в него (ако е намерена 
позивна (интервал)A5;, ние искаме да търсим точно нея, заради това използваме fgrep) и след като намерим точното място 
на съответната позивна, изрязваме колона 6, защото там е информацията за ITU зоната на държавата, в която се намира 
намерената позивна. Записваме получения резултат в ITU, защото вече сме намерили ITU зона за съответната позивна.

По аналогичен начин подхождаме и за WAZ зоната с разликите:
- ограничителите ни вече не са [], както е при ITU зоната, а тук ограничители са ().
- ако съответната позивна няма собствена WAZ зона, то тогава изрязваме колона 5 от съответната държава на позивната, а не 
колона 6, защото колона 5 е за WAZ зоната на държавата, а колона 6 е за ITU зоната на държавата.

След като вече сме намерили ITU и WAZ зоните за подадената позивна, то тогава ги извеждаме.

Цялата функция като код изглежда така:

function findZones
{
        FOUND_SIGN=$(findSign "${SIGN}")

        if [ -z "${FOUND_SIGN}" ]; then
                rm "${FILE}"
                exit 0
        fi

        #check if found sign has own ITU zone 
        echo "${FOUND_SIGN}" | egrep -q "\["

        if [ $? -eq 0 ]; then
                ITU=$(echo "${FOUND_SIGN}" | cut -d '[' -f2 | cut -d ']' -f1)
        else
                ITU=$(cat "${FILE}" \
                      | fgrep "${FOUND_SIGN}" \
                      | cut -d ',' -f6)
        fi

        #check if found sign has WAZ zone
        echo "${FOUND_SIGN}" | egrep -q "\("

        if [ $? -eq 0 ]; then
                WAZ=$(echo "${FOUND_SIGN}" | cut -d '(' -f2 | cut -d ')' -f1)
        else
                WAZ=$(cat "${FILE}" \
                      | fgrep "${FOUND_SIGN}" \
                      | cut -d ',' -f5)
        fi

        echo "${ITU} ${WAZ}"
}

11. function findDistance: В тази функция първо си създаваме променливите FOUND_SIGN_ONE и FIND_SIGN_TWO:
FOUND_SIGN_ONE=$(findSign "${SIGN}") -> това е първата позивна, която е подадена като трети аргумент
FOUND_SIGN_TWO=$(findSign "${SECOND_SIGN}") -> това е втората позивна, която е подадена като четвърти аргумент

Искаме на функцията findSign да подадем позивната SIGN, за да открие във файла FILE дали се среща тази позивна и намереният 
резултат да се запише в създадената променлива FOUND_SIGN_ONE. По същия начин и за FOUND_SIGN_TWO - искаме на функцията 
findSign да подадем позивната SECOND_SIGN, за да открие дали файлът FILE съдържа тази позивна и да я запише във 
FOUND_SIGN_TWO. Ако някоя от двете променливи FOUND_SIGN_ONE и FOUND_SIGN_TWO е празна (не е открита позивна), тогава 
ние изтриваме временния файл FILE и прекратяваме функцията. Ако съответно и двете позивни са коректни и ги има във файла 
FILE, то тогава следва да запишем средните географски ширини и средните географски дължини на двете позивни в променливи, 
след което да ги подадем като параметри на функцията getDistance, за да се изчисли разстоянието между подадените позивни.

Създаваме си променливите LATITUDE_ONE, LONGITUDE_ONE, LATITUDE_TWO, LONGITUDE_TWO, в които записваме съответно:
-средната географска ширина на първата позивна
-средната географска дължина на първата позивна
-средната географска ширина на втората позивна
-средната географска дължина на втората позивна

Средната географска ширина на всяка държава се намира в колона 7, а средната географска дължина - в колона 8.

Заради това към създадените променливи подаваме точно конкретно намерените изрази (заради това използваме fgrep) и изрязваме 
съответните колони. Като код това изглежда по следния начин:

function findDistance
{
        FOUND_SIGN_ONE=$(findSign "${SIGN}")
        FOUND_SIGN_TWO=$(findSign "${SECOND_SIGN}")

        if [ -z "${FOUND_SIGN_ONE}" -o -z "${FOUND_SIGN_TWO}" ]; then
                echo "One of the signs are missing from the file"
                rm "${FILE}"
                exit 10
        fi

        LATITUDE_ONE=$(cat "${FILE}" \
                    | fgrep "${FOUND_SIGN_ONE}" \
                    | cut -d ',' -f7)

        LONGITUDE_ONE=$(cat "${FILE}" \
                      | fgrep "${FOUND_SIGN_ONE}" \
                      | cut -d ',' -f8)

        LATITUDE_TWO=$(cat "${FILE}" \
                    | fgrep "${FOUND_SIGN_TWO}" \
                    | cut -d ',' -f7)

        LONGITUDE_TWO=$(cat "${FILE}" \
                      | fgrep "${FOUND_SIGN_TWO}" \
                      | cut -d ',' -f8)

        RESULT=$(getDistance "${LATITUDE_ONE}" "${LONGITUDE_ONE}" "${LATITUDE_TWO}" "${LONGITUDE_TWO}")

        echo "${RESULT}"
}

След като вече имаме средните географски ширини и дължини, то тогава ги подаваме като параметри на функцията getDistance, 
която трябва да изчисли разстоянието между въведените позивни, използвайки средните им географски ширини и дължини, и 
полученото разстояние да го запишем в променливата RESULT, която след това да изведем.

12. function getDistance и function convertToRadians -> и двете функции са взети като формула от интернет - използва се 
формулата на Хаверсин (Haversine formula).

I. function convertToRadians: Създаваме променливата DEGREE, която приема първия подаден аргумент към функцията. В 
променливата RESULT се записва стойността на DEGREE, умножена по 3.1415926/180 (DEGREE*3.1415926/180 -> по този 
начин се превръща в радиани). 
Функцията изглежда по следния начин:

function convertToRadians
{
        DEGREE="${1}"
        RESULT=$(awk 'BEGIN{ print '${DEGREE}'*3.1415926/180}')
        echo "${RESULT}"
}

II. function getDistance: В нея ще използваме горната функция convertToRadians, за да може да се извърши изчислението по 
формулата на Хаверсин. Първоначално в самата функция се записват подадените 4 аргумента:
1. средната географска ширина на първата позивна в променлива LATITUDE_ONE
2. средната географска дължина на първата позивна в променлива LONGITUDE_ONE
3. средната географска ширина на втората позивна в променлива LATITUDE_TWO
4. средната географска дължина на втората позивна в променлива LONGITUDE_TWO

След това проверяваме дали средната географска ширина на първата позивна съвпада със средната географска ширина на втората 
позивна и дали средната географска дължина на първата позивна съвпада със средната географска дължина на втората позивна. 
Ако съвпадат по този начин, то тогава разстоянието е 0. Извеждаме, че разстоянието е 0 и прекратяваме функцията.
Ако не съвпадат, то тогава продължаваме надолу, използвайки формулата на Хаверсин.
Намираме разликата на двете средни географски ширини, като от втората изваждаме първата. - DIFFERENCE_LATITUDE
Намираме разликата на двете средни географски дължини, като от втората изваждаме първата. - DIFFERENCE_LONGITUDE

Намерената разлика на средните географски ширини я превръщаме в радиани с помощта на функцията convertToRadians. Записваме 
резултата в променливата RADIANS_DIFFERENCE_LATITUDE
Намерената разлика на средните географски дължини я превръщаме в радиани с помощта на функцията convertToRadians. Записваме 
резултата в променливата RADIANS_DIFFERENCE_LONGITUDE

Разделяме на 2 превърнатата в радиани разлика на средните географски ширини - DLAT
Разделяме на 2 превърнатата в радиани разлика на средните географски дължини - DLON

Превръщаме в радиани средната географска ширина на първата позивна с помощта на функцията convertToRadians. Записваме 
резултата в променливата RADIANS_LATITUDE_ONE.
Превръщаме в радиани средната географска ширина на втората позивна с помощта на функцията convertToRadians. Записваме 
резултата в променливата RADIANS_LATITUDE_TWO.

В променливата MATH_ONE записваме резултата от формулата 
(sin(DLAT))^2+cos(RADIANS_LATITUDE_ONE)*cos(RADIANS_LATITUDE_TWO)*(sin(DLON))^2

В променливата MATH_TWO записваме резултата от формулата
2*atan2(sqrt(MATH_ONE),sqrt(1-(MATH_ONE)))

В условието на задачата е написано да приемем, че радиусът на земята е 6371 км, заради това в променлива RADIUS задаваме 
стойност 6371.

Крайният резултат е в променливата FINAL, в която се съдържа формулата RADIUS*MATH_TWO

Извеждаме крайния резултат, закръглен нагоре.

Кодът на функцията изглежда по този начин:

function getDistance
{
        LATITUDE_ONE="${1}"
        LONGITUDE_ONE="${2}"
        LATITUDE_TWO="${3}"
        LONGITUDE_TWO="${4}"

        if [ "${LATITUDE_ONE}" = "${LATITUDE_TWO}" -a "${LONGITUDE_ONE}" = "${LONGITUDE_TWO}" ]; then
                echo '0'
                return
        fi

        DIFFERENCE_LATITUDE=$(bc <<< "${LATITUDE_TWO}-(${LATITUDE_ONE})")
        DIFFERENCE_LONGITUDE=$(bc <<< "${LONGITUDE_TWO}-(${LONGITUDE_ONE})")

        RADIANS_DIFFERENCE_LATITUDE=$(convertToRadians "${DIFFERENCE_LATITUDE}")
        RADIANS_DIFFERENCE_LONGITUDE=$(convertToRadians "${DIFFERENCE_LONGITUDE}")

        DLAT=$(awk 'BEGIN{ print '${RADIANS_DIFFERENCE_LATITUDE}'/2 }')
        DLON=$(awk 'BEGIN{ print '${RADIANS_DIFFERENCE_LONGITUDE}'/2 }')

        RADIANS_LATITUDE_ONE=$(convertToRadians "${LATITUDE_ONE}")
        RADIANS_LATITUDE_TWO=$(convertToRadians "${LATITUDE_TWO}")

        MATH_ONE=$(awk 'BEGIN{ print (sin('${DLAT}'))^2+cos('${RADIANS_LATITUDE_ONE}')*cos('${RADIANS_LATITUDE_TWO}')*(sin
('${DLON}'))^2 }')

        MATH_TWO=$(awk 'BEGIN{ print 2*atan2(sqrt('${MATH_ONE}'),sqrt(1-('${MATH_ONE}'))) }')

        RADIUS=6371

        FINAL=$(awk 'BEGIN{ print '${RADIUS}'*'${MATH_TWO}' }')

        awk 'BEGIN{ printf "%3.0f\n", '${FINAL}' }'
}

Най-отдолу в скрипта имаме различни случаи за извикване на функциите findCountry, findZones и findDistance спрямо 
подадената команда.
Ако подадената команда е country, то тогава извикваме функция findCountry
Ако подадената команда е zones, то тогава извикваме функция findZones
Ако подадената команда е distance, то тогава извикваме функция findDistance
Ако подадената команда не е разпозната, то тогава извеждаме съобщение за грешка, изтриваме временния файл FILE и 
прекратяваме скрипта.
Ако подадената команда е някоя сред country, zones, distance, то тогава след извикване на някоя конкретна функция, 
изтриваме временния файл FILE и прекратяваме изпълнението на скрипта.

Използвани материали:
https://askubuntu.com/questions/164056/how-do-i-combine-all-lines-in-a-text-file-into-a-single-line -> сливане на всички 

редове в 
един цял -> tr -d '\r\n'

https://www.unix.com/shell-programming-and-scripting/118279-sed-append-first-column.html -> за добавяне на колони към файл

https://rosettacode.org/wiki/Haversine_formula

https://www.unix.com/unix-for-dummies-questions-and-answers/161774-sin-cos-awk.html -> тригонометрични функции в awk

https://unix.stackexchange.com/questions/131073/awk-printf-number-in-width-and-round-it-up -> закръгляне на число нагоре
